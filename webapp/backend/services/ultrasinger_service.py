"""UltraSinger integration service for processing audio files"""

import asyncio
import logging
import sys
import os
from pathlib import Path
from typing import Callable

logger = logging.getLogger(__name__)


async def process_with_ultrasinger(
    input_file: Path,
    output_dir: Path,
    language: str,
    whisper_model: str = "medium",
    crepe_model: str = "full",
    force_cpu: bool = False,
    ultrasinger_src_path: Path = None,
    progress_callback: Callable[[str, str, float], None] | None = None
) -> Path:
    """
    Process audio file with UltraSinger

    Args:
        input_file: Path to input audio file
        output_dir: Directory for output files
        language: Language code (it, en, pl)
        whisper_model: Whisper model size
        crepe_model: Crepe model size
        force_cpu: Force CPU processing
        ultrasinger_src_path: Path to UltraSinger src directory
        progress_callback: Optional callback for progress updates (step, message, percentage)

    Returns:
        Path to generated .txt file
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    # Build command line arguments
    args = [
        "-i", str(input_file),
        "-o", str(output_dir),
        "--whisper", whisper_model,
        "--crepe", crepe_model,
        "--language", language,
        "--format_version", "1.2.0",
    ]

    if force_cpu:
        args.append("--force_cpu")

    # Import and run UltraSinger
    try:
        # Add UltraSinger src to path
        if ultrasinger_src_path:
            sys.path.insert(0, str(ultrasinger_src_path))

        # Import after adding to path
        from UltraSinger import run, init_settings, check_requirements, settings as us_settings
        from Settings import Settings

        logger.info(f"Processing with args: {args}")

        # Update progress
        if progress_callback:
            progress_callback("separating", "Initializing UltraSinger...", 0)

        # Start progress monitor if callback provided
        monitor = None
        monitor_task = None
        if progress_callback:
            monitor = UltrasingerProgressMonitor(output_dir, progress_callback)
            monitor_task = asyncio.create_task(monitor.start())

        try:
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                _run_ultrasinger_sync,
                args,
                None  # Don't pass callback - monitor handles it
            )
        finally:
            # Stop monitor
            if monitor:
                monitor.stop()
            if monitor_task:
                await monitor_task

        # Find the generated .txt file
        txt_files = list(output_dir.glob("**/*.txt"))
        if not txt_files:
            raise RuntimeError("No .txt file generated by UltraSinger")

        result_file = txt_files[0]
        logger.info(f"Generated file: {result_file}")

        if progress_callback:
            progress_callback("generating", "Processing completed!", 100)

        return result_file

    except Exception as e:
        logger.error(f"UltraSinger processing failed: {e}", exc_info=True)
        raise RuntimeError(f"Processing failed: {str(e)}")


def _run_ultrasinger_sync(args: list[str], progress_callback: Callable | None = None) -> tuple:
    """Synchronous UltraSinger runner"""
    # Import here to avoid import issues
    from UltraSinger import run, init_settings, check_requirements, settings as us_settings

    # Initialize settings
    init_settings(args)

    # Check requirements
    check_requirements()

    # Mock progress updates (UltraSinger doesn't have native progress callbacks)
    if progress_callback:
        # We'll simulate progress based on typical pipeline stages
        steps = [
            ("separating", "Separating vocals from audio...", 20),
            ("transcribing", "Transcribing lyrics with Whisper...", 50),
            ("pitching", "Detecting pitch with Crepe...", 75),
            ("generating", "Generating UltraStar file...", 90),
        ]

        # Run each step (this is a simulation - actual UltraSinger runs as one block)
        # In production, you'd want to modify UltraSinger.py to emit progress events

    # Run UltraSinger
    result = run()

    return result


class UltrasingerProgressMonitor:
    """Monitor UltraSinger processing progress by watching output directory and logs"""

    def __init__(self, output_dir: Path, progress_callback: Callable):
        self.output_dir = output_dir
        self.progress_callback = progress_callback
        self._monitoring = False
        self._reported_stages = set()

    async def start(self):
        """Start monitoring"""
        self._monitoring = True
        self._reported_stages = set()

        while self._monitoring:
            await asyncio.sleep(1)  # Check every second for responsive updates

            # Check for cache files to determine progress
            cache_dir = self.output_dir / "cache"
            if cache_dir.exists():
                # Stage 1: Vocal separation (0-25%)
                if "vocals" not in self._reported_stages and (cache_dir / "vocals.wav").exists():
                    self._reported_stages.add("vocals")
                    self.progress_callback("separating", "Vocals separated successfully", 25)
                    logger.debug("Progress: Vocals separated (25%)")

                # Stage 2: Transcription (25-60%)
                if "transcription" not in self._reported_stages and (cache_dir / "transcribed_data.json").exists():
                    self._reported_stages.add("transcription")
                    self.progress_callback("transcribing", "Lyrics transcribed", 60)
                    logger.debug("Progress: Transcription complete (60%)")

                # Stage 3: Pitch detection (60-85%)
                if "pitch" not in self._reported_stages and (cache_dir / "pitched_data.json").exists():
                    self._reported_stages.add("pitch")
                    self.progress_callback("pitching", "Pitch detection complete", 85)
                    logger.debug("Progress: Pitch detection complete (85%)")

            # Check for final output (85-95%)
            if "output" not in self._reported_stages and list(self.output_dir.glob("*.txt")):
                self._reported_stages.add("output")
                self.progress_callback("generating", "UltraStar file generated", 95)
                logger.debug("Progress: File generation complete (95%)")
                self._monitoring = False

    def stop(self):
        """Stop monitoring"""
        self._monitoring = False
